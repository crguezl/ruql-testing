<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>REPASO. 2ª PARTE. <br />
ANÁLISIS SINTÁCTICO</title>
    <!-- Latest compiled and minified CSS -->
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css">
    <!-- -->
    <style type="text/css" media="all">
      div.quiz, p.comment, div.explanation {display:inline;}
      strong.correct {color:#14B63F;}
      strong.incorrect {color:rgb(255,0,0);}
      strong.mark {color:rgb(255,128,0);}
      input.correct {color:#14B63F; font-weight: bold;}
      input.incorrect {color:rgb(255,0,0); font-weight: bold;}
      div.custom-header {background-color:#7a3b7a; color:#FFFFFF; font-weight: bold;}
      body {padding-top: 20px; padding-bottom: 20px; margin-bottom: 20px;}
      html {position: relative; min-height: 100%;}
      .navbar {margin-bottom: 20px;}
      .btn-footer {text-align: center;}
      #footer {
        position: absolute;
        bottom: 0;
        height: 30px;
        width: inherit;
      }
      div.container {background-color:#EAEAEA;}
      p.comment, div.explanation {font-style: italic;}
      .links {
        display: inline; 
        padding-right:5px;
      }
      a.links:hover {color: #FFCCFF;}
    </style>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}});
    </script>
  </head>
  <body>
    <div class="container">
      
        <div class="navbar navbar-default custom-header">
          <div class="navbar-header">
            <h3>REPASO. 2ª PARTE. <br />
ANÁLISIS SINTÁCTICO</h3>
          </div>
          <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
              <li>Asignatura: PROCESADORES DE LENGUAJES</li><br/>
              <li>Curso: 3º</li><br/>
              <li>
                  Escuela T&eacute;cnica Superior de Ingenier&iacute;a Inform&aacute;tica
                  </li><br/>
              <li>Universidad de la Laguna </li>
            </ul>
          </div>
        </div>
      
      <!-- Seed: 217729378288457318654986761148255026365 -->
<form id="form">
  <ol class="questions">
    <li id="question-0" class="question fillin ">
      <div class="quiz text">
[1 point] 
Dado un conjunto $A$, se define $A^*$ el cierre de Kleene de $A$ como:
\( A^* = \cup_{n=1}^{\infty} A^n \)
Se admite que $A^0 = { \epsilon }$, donde $\epsilon$ denota la
<input type=text id=qfi1-1 class=fillin></input> <input type=text id=qfi1-2 class=fillin></input>, esto es
la palabra que tiene longitud cero, formada por cero símbolos del conjunto base $A$<div id=qfi1-3r class=quiz></div></br></br>      </div>
    </li>
    <li id="question-1" class="question fillin ">
      <div class="quiz text">
[1 point] 
Una producción de la forma $A \rightarrow A \alpha$.
se dice que es <input type=text id=qfi2-1 class=fillin></input> por la <input type=text id=qfi2-2 class=fillin></input>
<div id=qfi2-2r class=quiz></div></br></br>      </div>
    </li>
    <li id="question-2" class="question fillin ">
      <div class="quiz text">
[1 point] 
Recuerde el <b>analizador sintáctico descendente predictivo recursivo</b> 
para la <a id="grammar">gramática</a>:<br/>
<ul>
  <li> $\Sigma = { ; =, ID, P, +, *, (, ), NUM }$, 
  <li> $V = { statements, statement, expression, term, factor }$
  <li> Productions:
  <ol>
    <li>
    statements  $ \rightarrow$ statement ';' statements  $\vert$ statement
    <li>
    statement  $ \rightarrow$ ID '=' expression  $\vert$ P expression
    <li>
    expression  $ \rightarrow$ term '+' expression  $\vert$ term
    <li>
    term  $ \rightarrow$ factor '*' term  $\vert$ factor
    <li>
    factor  $ \rightarrow$ '(' expression ')' $\vert$ ID $ \vert$ NUM
  </ol>
  <li> Start symbol: $statements$
</ul>
Rellene las partes que faltan de código CoffeeScript del 
método que se encarga de reconocer el lenguaje generado
por <tt>expression</tt>:
<pre>
  expression = ->
    result = term()
    while <input type=text id=qfi3-1 class=fillin></input> and <input type=text id=qfi3-2 class=fillin></input> is "ADDOP"
      type = lookahead.value
      match "ADDOP"
      right = <input type=text id=qfi3-3 class=fillin></input>
      result =
        type: type
        left: result
        right: right
    result
</pre>
<div id=qfi3-4r class=quiz></div></br></br>      </div>
    </li>
    <li id="question-3" class="question fillin ">
      <div class="quiz text">
[1 point] 
Rellene las partes que faltan de código CoffeeScript del 
método que se encarga de reconocer el lenguaje generado
por <tt>statement</tt> para la <a href="#grammar">gramática
definida anteriormente</a>:
<pre>
    statement = function() {
      var left, result, right;
      result = null;
      if (<input type=text id=qfi4-1 class=fillin></input> && <input type=text id=qfi4-2 class=fillin></input> === "ID") {
        left = {
          type: "<input type=text id=qfi4-3 class=fillin></input>",
          value: <input type=text id=qfi4-4 class=fillin></input>.value
        };
        match("ID");
        match("=");
        right = <input type=text id=qfi4-5 class=fillin></input>();
        result = {
          type: "=",
          left: left,
          right: right
        };
      } else if (<input type=text id=qfi4-6 class=fillin></input> && <input type=text id=qfi4-7 class=fillin></input>.<input type=text id=qfi4-8 class=fillin></input> === "P") {
        match("P");
        right = expression();
        result = {
          type: "P",
          value: <input type=text id=qfi4-9 class=fillin></input>
        };
      } else if (<input type=text id=qfi4-10 class=fillin></input> && <input type=text id=qfi4-11 class=fillin></input>.<input type=text id=qfi4-12 class=fillin></input> === "IF") {
        match("<input type=text id=qfi4-13 class=fillin></input>");
        left = <input type=text id=qfi4-14 class=fillin></input>;
        match("THEN");
        right = <input type=text id=qfi4-15 class=fillin></input>;
        result = {
          type: "IF",
          left: <input type=text id=qfi4-16 class=fillin></input>,
          right: <input type=text id=qfi4-17 class=fillin></input>
        };
      } else {
        throw "Syntax Error. Expected identifier but found " + 
         (lookahead ? lookahead.value : "end of input") + 
         (" near '" + (input.substr(lookahead.from)) + "'");
      }
      return result;
    };
</pre>
<div id=qfi4-18r class=quiz></div></br></br>      </div>
    </li>
    <li id="question-4" class="question fillin ">
      <div class="quiz text">
[1 point] 
Complete este fragmento de <tt>slim</tt> que establece el favicon de 
la página HTML:
<pre>
    link rel="<input type=text id=qfi5-1 class=fillin></input>" type="image/jpg" href="images/favicon.jpg"
</pre><div id=qfi5-2r class=quiz></div></br></br>      </div>
    </li>
  </ol>
  <div class="btn-footer">
    <button type="button" id="submit" class="btn btn-primary">
Submit    </button>
    <button type="button" id="reset" class="btn btn-warning">
Reset    </button>
  </div>
</form>

      
        <div id="footer">
          <div class="row text-muted">
            <div class="col-md-6">
              Quiz generated using the RuQL Gem. For more information, visit <a href="https://github.com/jjlabrador/ruql">GitHub
              <span class="glyphicon glyphicon-link"></span></a>
            </div>
            <div class="col-md-3"></div>
            <div class="col-md-3">
              Universidad de La Laguna 2014
            </div>
          </div>
        </div>
      
    </div>
    <script type="text/javascript" src="http://code.jquery.com/jquery-2.1.0.min.js"></script>
    <!--[if lt IE 8]>
      <script type="text/javascript" src="http://code.jquery.com/jquery-1.11.0.min.js"></script>
    <![endif]-->
    <script>      data = {"question-0":{"question_text":"\nDado un conjunto $A$, se define $A^*$ el cierre de Kleene de $A$ como:\n\\( A^* = \\cup_{n=1}^{\\infty} A^n \\)\nSe admite que $A^0 = { \\epsilon }$, donde $\\epsilon$ denota la\n--- ---, esto es\nla palabra que tiene longitud cero, formada por cero símbolos del conjunto base $A$.","answers":{"qfi1-1":{"answer_text":"/palabra/i","correct":true,"explanation":null,"type":"Regexp"},"qfi1-2":{"answer_text":"/vac[ií]a/","correct":true,"explanation":null,"type":"Regexp"}},"points":1,"order":false,"question_comment":""},"question-1":{"question_text":"\nUna producción de la forma $A \\rightarrow A \\alpha$.\nse dice que es --- por la ---\n","answers":{"qfi2-1":{"answer_text":"/recursiva/i","correct":true,"explanation":null,"type":"Regexp"},"qfi2-2":{"answer_text":"/izquierda/i","correct":true,"explanation":null,"type":"Regexp"}},"points":1,"order":false,"question_comment":""},"question-2":{"question_text":"\nRecuerde el <b>analizador sintáctico descendente predictivo recursivo</b> \npara la <a id=\"grammar\">gramática</a>:<br/>\n<ul>\n  <li> $\\Sigma = { ; =, ID, P, +, *, (, ), NUM }$, \n  <li> $V = { statements, statement, expression, term, factor }$\n  <li> Productions:\n  <ol>\n    <li>\n    statements  $ \\rightarrow$ statement ';' statements  $\\vert$ statement\n    <li>\n    statement  $ \\rightarrow$ ID '=' expression  $\\vert$ P expression\n    <li>\n    expression  $ \\rightarrow$ term '+' expression  $\\vert$ term\n    <li>\n    term  $ \\rightarrow$ factor '*' term  $\\vert$ factor\n    <li>\n    factor  $ \\rightarrow$ '(' expression ')' $\\vert$ ID $ \\vert$ NUM\n  </ol>\n  <li> Start symbol: $statements$\n</ul>\nRellene las partes que faltan de código CoffeeScript del \nmétodo que se encarga de reconocer el lenguaje generado\npor <tt>expression</tt>:\n<pre>\n  expression = ->\n    result = term()\n    while --- and --- is \"ADDOP\"\n      type = lookahead.value\n      match \"ADDOP\"\n      right = ---\n      result =\n        type: type\n        left: result\n        right: right\n    result\n</pre>\n","answers":{"qfi3-1":{"answer_text":"lookahead","correct":true,"explanation":null,"type":"String"},"qfi3-2":{"answer_text":"lookahead.type","correct":true,"explanation":null,"type":"String"},"qfi3-3":{"answer_text":"term()","correct":true,"explanation":null,"type":"String"}},"points":1,"order":false,"question_comment":""},"question-3":{"question_text":"\nRellene las partes que faltan de código CoffeeScript del \nmétodo que se encarga de reconocer el lenguaje generado\npor <tt>statement</tt> para la <a href=\"#grammar\">gramática\ndefinida anteriormente</a>:\n<pre>\n    statement = function() {\n      var left, result, right;\n      result = null;\n      if (--- && --- === \"ID\") {\n        left = {\n          type: \"---\",\n          value: ---.value\n        };\n        match(\"ID\");\n        match(\"=\");\n        right = ---();\n        result = {\n          type: \"=\",\n          left: left,\n          right: right\n        };\n      } else if (--- && ---.--- === \"P\") {\n        match(\"P\");\n        right = expression();\n        result = {\n          type: \"P\",\n          value: ---\n        };\n      } else if (--- && ---.--- === \"IF\") {\n        match(\"---\");\n        left = ---;\n        match(\"THEN\");\n        right = ---;\n        result = {\n          type: \"IF\",\n          left: ---,\n          right: ---\n        };\n      } else {\n        throw \"Syntax Error. Expected identifier but found \" + \n         (lookahead ? lookahead.value : \"end of input\") + \n         (\" near '\" + (input.substr(lookahead.from)) + \"'\");\n      }\n      return result;\n    };\n</pre>\n","answers":{"qfi4-1":{"answer_text":"lookahead","correct":true,"explanation":null,"type":"String"},"qfi4-2":{"answer_text":"lookahead.type","correct":true,"explanation":null,"type":"String"},"qfi4-3":{"answer_text":"id","correct":true,"explanation":null,"type":"String"},"qfi4-4":{"answer_text":"lookahead","correct":true,"explanation":null,"type":"String"},"qfi4-5":{"answer_text":"expression","correct":true,"explanation":null,"type":"String"},"qfi4-6":{"answer_text":"lookahead","correct":true,"explanation":null,"type":"String"},"qfi4-7":{"answer_text":"lookahead","correct":true,"explanation":null,"type":"String"},"qfi4-8":{"answer_text":"type","correct":true,"explanation":null,"type":"String"},"qfi4-9":{"answer_text":"right","correct":true,"explanation":null,"type":"String"},"qfi4-10":{"answer_text":"lookahead","correct":true,"explanation":null,"type":"String"},"qfi4-11":{"answer_text":"lookahead","correct":true,"explanation":null,"type":"String"},"qfi4-12":{"answer_text":"type","correct":true,"explanation":null,"type":"String"},"qfi4-13":{"answer_text":"if","correct":true,"explanation":null,"type":"String"},"qfi4-14":{"answer_text":"/expression|condition/","correct":true,"explanation":null,"type":"Regexp"},"qfi4-15":{"answer_text":"/statement/","correct":true,"explanation":null,"type":"Regexp"},"qfi4-16":{"answer_text":"/left/","correct":true,"explanation":null,"type":"Regexp"},"qfi4-17":{"answer_text":"/right/","correct":true,"explanation":null,"type":"Regexp"}},"points":1,"order":false,"question_comment":""},"question-4":{"question_text":"\nComplete este fragmento de <tt>slim</tt> que establece el favicon de \nla página HTML:\n<pre>\n    link rel=\"---\" type=\"image/jpg\" href=\"images/favicon.jpg\"\n</pre>","answers":{"qfi5-1":{"answer_text":"icon","correct":true,"explanation":null,"type":"String"}},"points":1,"order":false,"question_comment":""}};

      function findCorrectAnswer(idQuestion, questionType) {
        correctIds = [];
        for (id in data[idQuestion]['answers']) {
          if(data[idQuestion]['answers'][id.toString()]['correct'] == true)
            if (questionType == 0)
              return id.toString();
            else {
              correctIds.push(id.toString());
            } 
        }
        return correctIds;
      }
      
      function checkSelectMultiple(x, checkedIds, correctIds) {
        results = [];
        
        $.each(checkedIds, function(index, value){
          if (correctIds.indexOf(value) == -1) {
            results.push(false);
            printResults(value, 0, data[x.toString()]['answers'][value]['explanation'], 0);
          }
          else {
            results.push(true);
            printResults(value, 1, data[x.toString()]['answers'][value]['explanation'], 0);
          }
        });
        
        nCorrects = 0;
        nIncorrects = 0;
        $.each(results, function(index, value){
          if (value == true)
            nCorrects += 1;
          else
            nIncorrects += 1;
        });
        
        calculateMark(data[x.toString()], x.toString(), null, 3, nCorrects, nIncorrects);
      }
      
      function printResults(id, type, explanation, typeQuestion) {
        if (typeQuestion == 0) {                                        // MultipleChoice and SelectMultiple
          $("br[class=" + id + "br" + "]").detach();
          if (type == 1) {
            if ((explanation == "") || (explanation == null))
              $("div[id ~= " + id + "r" + "]").html("<strong class=correct> Correct</strong></br>");
            else
              $("div[id ~= " + id + "r" + "]").html("<strong class=correct> Correct - " + explanation + "</strong></br>");
          }
          else {
            if ((explanation == "") || (explanation == null))
              $("div[id ~= " + id + "r" + "]").html("<strong class=incorrect> Incorrect</strong></br>");
            else
              $("div[id ~= " + id + "r" + "]").html("<strong class=incorrect> Incorrect - " + explanation + "</strong></br>");
          }
        }
        else {          // FillIn
          for (r in id) {
            input = $("#" + r.toString());
            if (id[r] == true)
              input.attr('class', 'fillin correct');
            else { 
              if ((id[r] == false) || (id[r] != "n/a"))
                input.attr('class', 'fillin incorrect');
            }
            
            if ((id[r] != true) && (id[r] != false) && (id[r] != "n/a")) {
              if (explanation[id[r].toString()] != null)
                $("div[id ~= " + r.toString() + "r" + "]").html(" <div class=explanation>" + explanation[id[r].toString()] + "</div>");
            }
            else {
              if (explanation[r] != null)
                $("div[id ~= " + r + "r" + "]").html(" <div class=explanation>" + explanation[r] + "</div>");
            }
          }
        }
      }
      
      function calculateMark(question, id, result, typeQuestion, numberCorrects, numberIncorrects) {
        if (typeQuestion == 2) {
          if (result)
            $("#" + id).append("<strong class=mark> " + question['points'].toFixed(2) + "/" + question['points'].toFixed(2) + " points</strong></br></br>");
          else
            $("#" + id).append("<strong class=mark> 0.00/" + question['points'].toFixed(2) + " points</strong></br></br>");
        }
        else if (typeQuestion == 1) {
          size = 0;
          for (y in question['answers'])
            if (question['answers'][y]['correct'] == true)
              size += 1;
          
          $("#" + id).append("<strong class=mark> " + ((question['points'] / size) * numberCorrects).toFixed(2) + "/" + question['points'].toFixed(2) + " points</strong></br></br>");
        }
        else {
          totalCorrects = 0;
          for (y in question['answers']) {
            if (question['answers'][y]['correct'] == true)
              totalCorrects += 1;
          }
          
          correctAnswerPoints = question['points'] / totalCorrects;
          penalty = correctAnswerPoints * numberIncorrects;
          mark = (correctAnswerPoints * numberCorrects) - penalty;
          
          if (mark < 0)
            mark = 0;
            
          $("#" + id).append("<strong class=mark> " + mark.toFixed(2) + "/" + question['points'].toFixed(2) + " points</strong></br></br>");        
        }
      }
      
      function checkFillin(correctAnswers, userAnswers, distractorAnswers, typeCorrection) {
        correction = {};
        checkedAnswers = {};
        
        if (typeCorrection == 0) {          // Order doesn't matter
          for (u in userAnswers) {
            if (userAnswers[u] != undefined) {    // No empty field
              matchedCorrect = false;
              for (y in correctAnswers) {
                if (checkAnswers[u] == undefined) {
                  if ((typeof(correctAnswers[y]) == "string") || (typeof(correctAnswers[y]) == "number")) {    // Answer is a String or a Number
                    if (userAnswers[u] == correctAnswers[y]) {
                      correction[u] = true;
                      checkedAnswers[u] = userAnswers[u];
                      matchedCorrect = true;
                      break;
                    }
                  }
                  else {  // Answer is a Regexp
                    if (userAnswers[u].match(correctAnswers[y])) {
                      correction[u] = true;
                      checkedAnswers[u] = userAnswers[u];
                      matchedCorrect = true;
                      break;
                    }
                  }
                }
              }
              if (!matchedCorrect)
                correction[u] = false;
            }
            else
              correction[u] = "n/a";
          }
        }
        else {                            // Order matters
          for (u in userAnswers) {
            if (userAnswers[u] != undefined) {
              if ((typeof(correctAnswers[u]) == "string") || (typeof(correctAnswers[u]) == "number")) {
                if (userAnswers[u] == correctAnswers[u])
                  correction[u] = true;
                else
                  correction[u] = false;
              }
              else {
                if (userAnswers[u].match(correctAnswers[u]))
                  correction[u] = true;
                else
                  correction[u] = false;
              }
            }
            else
              correction[u] = "n/a";
          }
        }
        
        if (Object.keys(userAnswers).length == 1) {
          for (u in userAnswers) {
            if (correction[u] == false) {
              for (y in distractorAnswers) {
                if ((typeof(distractorAnswers[y]) == "string") || (typeof(distractorAnswers[y]) == "number")) {
                  if (userAnswers[u] == distractorAnswers[y])
                    correction[u] = y.toString();
                }
                else {
                  if (userAnswers[u].match(distractorAnswers[y]))
                    correction[u] = y.toString();
                }
              }
            }
          }
        }
        return correction;
      }
      
      function checkAnswers() {
        
        for (x in data) {
          if ($("#" + x.toString() + " strong").length == 0) {
            correct = false;
            answers = $("#" + x.toString() + " input");
            
            if (answers.attr('class') == "fillin") {
              correctAnswers = {};
              distractorAnswers = {};
              explanation = {};
              stringAnswer = false;
              
              for (ans in data[x.toString()]['answers']) {
                if (data[x.toString()]['answers'][ans]['correct'] == true) {
                  if (data[x.toString()]['answers'][ans]['type'] == "Regexp") {
                    string = data[x.toString()]['answers'][ans]['answer_text'].split('/');
                    regexp = string[1];
                    options = string[2];
                    correctAnswers[ans.toString()] = RegExp(regexp, options);
                  }
                  else { // String or Number
                    correctAnswers[ans.toString()] = data[x.toString()]['answers'][ans]['answer_text'];
                    stringAnswer = true;
                  }
                }
                else {
                  if (data[x.toString()]['answers'][ans]['type'] == "Regexp") {
                    string = data[x.toString()]['answers'][ans]['answer_text'].split('/');
                    regexp = string[1];
                    options = string[2];
                    distractorAnswers[ans.toString()] = RegExp(regexp, options);
                  }
                  else {// String or Number
                    distractorAnswers[ans.toString()] = data[x.toString()]['answers'][ans]['answer_text'];
                    stringAnswer = true;
                  }
                }
                explanation[ans] = data[x.toString()]['answers'][ans]['explanation'];
              }
              
              userAnswers = {};
              for (i = 0; i < answers.length; i++) {
                if (answers[i].value == '')
                  userAnswers[answers[i].id.toString()] = undefined;
                else
                  if (stringAnswer)
                    userAnswers[answers[i].id.toString()] = answers[i].value.toLowerCase();
                  else
                    userAnswers[answers[i].id.toString()] = answers[i].value;
              }
              
              if (data[x.toString()]['order'] == false)
                results = checkFillin(correctAnswers, userAnswers, distractorAnswers, 0);
              else
                results = checkFillin(correctAnswers, userAnswers, distractorAnswers, 1);
                
              allEmpty = true;
              nCorrects = 0;
              
              for (r in results) {
                if (results[r] == true)
                  nCorrects += 1;
                if (results[r] != "n/a")
                  allEmpty = false;
              }
              
              if (!allEmpty) {
                printResults(results, null, explanation, 1);
                calculateMark(data[x.toString()], x.toString(), null, 1, nCorrects, null);
              }
            }
            
            else if (answers.attr('class') == "select") {
              idCorrectAnswer = findCorrectAnswer(x.toString(), 0);
              
              if ($("#" + x.toString() + " :checked").size() != 0) {
                if ($("#" + x.toString() + " :checked").attr('id') == idCorrectAnswer) {
                  printResults($("#" + x.toString() + " :checked").attr('id'), 1, "", 0);
                  correct = true;
                }
                else {
                  id = $("#" + x.toString() + " :checked").attr('id');
                  printResults(id, 0, data[x.toString()]['answers'][id]['explanation'], 0);
                }
                calculateMark(data[x.toString()], x.toString(), correct, 2, null, null);
              }
            }
            
            else {
              if ($("#" + x.toString() + " :checked").size() != 0) {
                answers = $("#" + x.toString() + " :checked");
                checkedIds = [];
                
                $.each(answers, function(index, value){
                  checkedIds.push(value['id']);
                });
                
                correctIds = [];
                correctIds = findCorrectAnswer(x.toString(), 1);
                checkSelectMultiple(x, checkedIds, correctIds);
              }
            }
          }
        }
      }

      $("#submit").click(function() {
        checkAnswers();
        filledAllQuiz = true;
        
        for (x in data) {
          if ($("#" + x.toString() + " strong").length == 0)
            filledAllQuiz = false; 
        }
        if (filledAllQuiz)
          $("#submit").detach();
      });

      $("#reset").click(function() {
        window.location.reload();
      });
</script>
    <!-- Latest compiled and minified JavaScript -->
    <script src="http://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
    <!-- -->
  </body>
</html>
